#!/user/bin/python3.8           1.1 Концепция ООП простыми словами.
# -*- coding: utf-8 -*- 

# концепций функционального программирования было достаточно 
# до 1960-x гг. Когда, в общем то и зародилась эта концепция ООП.
# Почти всегда в программах мы оперируем объектами данных. 

# Например, 
# создается программа по учету животных, в частности, котов и кошек. Значит, 
# здесь мы имеем дело с объектом коты (Cats). И было бы хорошо все данные, 
# связанные с котами, представлять в программе как единое целое. Как раз 
# это можно сделать с помощью класса: 

Сats            # Название класса
---------
порода          # Свойства класса
имя             # которых тут три (3)
возраст

# Здесь класс можно воспринимать, как шаблон, по которому будут формироваться 
# данные о котах. В этом шаблоне есть три свойства: порода, имя и возраст. 
# Программист сам решает, сколько и какие свойства будет содержать класс. 
# Я решил, для примера, пусть будут такие. 

# А вот конкретные коты – это объекты данного класса: 

Сats            Сats            Сats            
---------       ---------       ---------
Бурма           Саванна         Русская          
Васька          Красик          Рыжик           
3               5               2

# И таких объектов может быть множество. То есть, объекты создаются по 
# образу и подобию шаблона – класса, в данном случае Cats. Далее в программе 
# мы можем работать с этими объектами-котами, как с единым целым. 

# Вообще, класс может содержать не только свойства, то есть, данные, но и 
# методы – набор функций, определенные для работы с классом и его объектами. 
# То есть, класс может описывать некий алгоритм, фрагмент программы, 
# присущий именно этому объекту. Например, в классе можно определить 
# метод (функцию), которая бы рисовала кота на экране устройства. Пусть, 
# для примера, она называется draw(): 

Сats            # Название класса
---------
порода          # Свойства класса
имя             # которых тут три (3)
возраст
____________
draw(): ...     # метод класса тоесть функции которые определены для работы
                # с классом и его объектами

# Тогда у каждого объекта этого класса можно будет вызывать метод draw() 
# и на экране будет рисоваться соответствующий кот.

Сats
---------
Бурма           --->> draw() # и будет нарисован именно наш "Бурма" 
Васька                       # по имени "Васька"
3

# Саму реализацию метода draw() мы прописываем сами
# Разумеется, таких методов в классах может быть сколько угодно. И они, 
# как правило, имеют доступ ко всем свойствам текущего класса и объекта. 
# В результате, в рамках одного класса можно сформировать полноценную 
# программу, которая часто работает независимо в каждом объекте этого класса. 

# Приведем еще такой пример допустим нам понадобилось вывести в одном окне 
# несколько независимых графиков функций: 

# Тогда можно определить класс Graphs для отображения и манипулирования 
# графиками (перемещение, изменение масштаба и прочее). А, затем, каждый 
# конкретный график становится просто объектом этого класса. 

# Отметим, что класс должен воспринематься как единая целостная конструкция,
# а все внутренние манипкляции с его данными, должны быть сокрыты в самом классе
# и в идеале недоступны из-вне. Тоесть программист использующий класс,
# не может использовать все его данные и методы, а он имеет доступ только
# к некоторым (разрешенным) методам и данным. Как на примере с машиной нам
# безралично как крутятся колеса... как работает двигатель это все скрыто
# нам достаточно что есть руль и мы можем ехать.

# Что бы пользователь не мог специально или случайно вмешаться во внутреннюю
# работу класса, данные и методы этого класса можно скрывать и уже к ним 
# можно будет обращаться только внутри класса. Этот механизм называют
# Инкапсуляцией. Благодоря инкапсуляции класс становится единым целым,
# а работа с ним возможна только через публицные доступные методы и свойства

# Еще одна важная идея объектно ориентированного программирования это
# Наследование. Наследование позволяет "вынести за скобки" общее для разных
# классов. Можно привести пример с разработкой графического редактора 
# где рисуем некие примитивы (линию, элепсы, прямоугольник, и т.д.)
# с точка зрения ООП каждый такой примитив удобно представить своим классом
# Но у каждого такого класса будут одинаковые свойства (координаты, толщина, цвет)
# Именно такие свойства целесообразно вывести в общий для всех "базовый класс"
# и уже все другие классы унаследовать от этого базового. В результате в 
# каждом из дочерних классов появятся все эти свойства.
# Благодоря наследованию можно расширять функционал ранее созданных классов

# Еще одна важная идея это Полиморфизм.
# Она означает что мы можем единым образом работать с разными типами данных.
# Вообще разлицают два типа полиморфизма: Ad hoc и Параметрический
# Ad hoc полиморфизм существовал еще до появления ООП и реализовывался
# через перегрузку функций и приведение различных типов данных
# Параметрический полиморфизм это то что используется как раз в python
# Вернувшись к примеру с рисованием примитивов. Это у нас может быть 
# функция (метод) в базовом классе, например для рисования примитива в окне.
# И будет достаточно создать единый список примитивов (объектов) каждый объект 
# которого будет приведен к типу базового класса и соответственно свой 
# метод рисования примитива.
# В итоге мы имеем единый интерфейс тоесть базовый класс для управления 
# самыми разыми графическими примитивами. И также, можно бужет добавить
# новые графические приметивы, просто унаследовав их от базового класса и 
# они буду встраиваться в общую логику работы программы. что очень удобно







